import { newHashFromBigInt, Proof, setBitBigEndian } from '@iden3/js-merkletree';
export class IssuerResolver {
    async resolve(credentialStatus) {
        const revStatusDTO = await (await fetch(credentialStatus.id)).json();
        return Object.assign(new RevocationStatusDTO(), revStatusDTO).toRevocationStatus();
    }
}
/**
 *  Proof dto as a partial result of fetching credential status with type SparseMerkleTreeProof
 *
 * @export
 * @class ProofDTO
 */
export class ProofDTO {
}
/**
 * RevocationStatusDTO is a result of fetching credential status with type SparseMerkleTreeProof
 *
 * @beta
 * @export
 * @class RevocationStatusDTO
 */
export class RevocationStatusDTO {
    toRevocationStatus() {
        const p = new Proof();
        p.existence = this.mtp.existence;
        p.nodeAux = this.mtp.node_aux
            ? {
                key: newHashFromBigInt(BigInt(this.mtp.node_aux.key)),
                value: newHashFromBigInt(BigInt(this.mtp.node_aux.value))
            }
            : undefined;
        const s = this.mtp.siblings.map((s) => newHashFromBigInt(BigInt(s)));
        p.siblings = [];
        p.depth = s.length;
        for (let lvl = 0; lvl < s.length; lvl++) {
            if (s[lvl].bigInt() !== BigInt(0)) {
                setBitBigEndian(p.notEmpties, lvl);
                p.siblings.push(s[lvl]);
            }
        }
        return {
            mtp: p,
            issuer: this.issuer
        };
    }
}
//# sourceMappingURL=sparse-merkle-tree.js.map
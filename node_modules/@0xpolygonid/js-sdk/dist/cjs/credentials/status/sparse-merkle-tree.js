"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RevocationStatusDTO = exports.ProofDTO = exports.IssuerResolver = void 0;
const js_merkletree_1 = require("@iden3/js-merkletree");
class IssuerResolver {
    async resolve(credentialStatus) {
        const revStatusDTO = await (await fetch(credentialStatus.id)).json();
        return Object.assign(new RevocationStatusDTO(), revStatusDTO).toRevocationStatus();
    }
}
exports.IssuerResolver = IssuerResolver;
/**
 *  Proof dto as a partial result of fetching credential status with type SparseMerkleTreeProof
 *
 * @export
 * @class ProofDTO
 */
class ProofDTO {
}
exports.ProofDTO = ProofDTO;
/**
 * RevocationStatusDTO is a result of fetching credential status with type SparseMerkleTreeProof
 *
 * @beta
 * @export
 * @class RevocationStatusDTO
 */
class RevocationStatusDTO {
    toRevocationStatus() {
        const p = new js_merkletree_1.Proof();
        p.existence = this.mtp.existence;
        p.nodeAux = this.mtp.node_aux
            ? {
                key: (0, js_merkletree_1.newHashFromBigInt)(BigInt(this.mtp.node_aux.key)),
                value: (0, js_merkletree_1.newHashFromBigInt)(BigInt(this.mtp.node_aux.value))
            }
            : undefined;
        const s = this.mtp.siblings.map((s) => (0, js_merkletree_1.newHashFromBigInt)(BigInt(s)));
        p.siblings = [];
        p.depth = s.length;
        for (let lvl = 0; lvl < s.length; lvl++) {
            if (s[lvl].bigInt() !== BigInt(0)) {
                (0, js_merkletree_1.setBitBigEndian)(p.notEmpties, lvl);
                p.siblings.push(s[lvl]);
            }
        }
        return {
            mtp: p,
            issuer: this.issuer
        };
    }
}
exports.RevocationStatusDTO = RevocationStatusDTO;
//# sourceMappingURL=sparse-merkle-tree.js.map